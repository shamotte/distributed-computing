signals:
    SIG_TABLE_REQ
    SIG_SIG_TABLE_ACK
    SIG_VOTE
    SIG_END_REQ
    SIG_GAME_END


struct queue_position {
    pid : int
    timestamp : int
}


state base{

    priority: int = null

    queue: vector<pid> = []
    data_form_who: array[bool] = []

    signal SIG_GAME_END{to_erase: array[int]}{
        queue.erase(to_erase)

    }

    signal SIG_TABLE_REQ:
        queue.insert(queue.find(timestamp > table_rek.timestamp).queue_position{SIG_TABLE_REQ})
        data_form_who[tabel_req] = true
        send(SIG_TABLE_ACK)

    
    signal SIG_TABLE_ACK:
        data_form_who[SIG_TABLE_ACK] = true

}


state idle{

    signal:

    logic:
        wait_for(random())
        priority = lampoet_counter
        goto seek;
}


state seek {

    logic {
        broadcast(SIG_TABLE_REQ)

        retry:

        wait_until(all(data_from_who))

        for table_num in table_count:
            for i in table seat_count:
                if queue[table_num * 4 + i] == pid:
                    goto play { table_companions = queue[i:i+3]}

        await SIG_GAME_END
        goto :retry
    }
}


state play{

    signal SIG_VOTE{
        SIG_VOTEs++
    }

    signal SIG_END_REQ{
        SIG_END_REQs++
    }

    table_companions :P array[int]

    SIG_VOTEs =0
    SIG_END_REQs =0

    logic:
    SIG_VOTE = random()

    for tc in table_companions{
        tc.send(SIG_VOTE)
    }

    wait_until(SIG_VOTEs == SIG_VOTEs_required)

    ///gra≈Ñsko


    wait_for(random())

    for tc in table_companions{
        tc.send(SIG_END_REQ)
    }

    if(pid == min(table_companions))
        breaodcast(SIG_GAME_END)
}