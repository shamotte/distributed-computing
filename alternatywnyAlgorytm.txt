// Programowanie Rozproszone - Projekt
// 8. Głosowanie staruszków.

// 156080, 156022

// Kwestie znaczników czasowych i roztrzygania konfliktów względem czasu odbywają się z wykorzystaniem licznika lamporta
// Jego implementacji nie opisujemy w poniższym pseudokodzie dla czytelności samej logiki stanów


// Sygnały
// Dodatkowo, każdy sygnał posiada pid (player id) oraz lamport_counter
signal
    SIG_TABLE_REQ(priority: int, vote: int)                 // zgłoszenie chęci dołączenia do stołu
    SIG_SIG_TABLE_ACK()                                     // uznanie chęci dołączenia do stołu
    SIG_TABLE(players: array[int], table_number: int)       // danie znać innym, że należą do stołu
    SIG_END_REQ                                             // zgłoszenie gotowości do zakończenia gry
    SIG_GAME_END(players: array[int], table_number: int)    // sygnał zakończenia gry, wysyłany przez 1 osobę na stół


// Stałe wynikające z zadania
const
    PLAYER_NUM,		    		// liczba graczy
	TABLE_NUM,          		// liczba stołów
    GAME_NUM,                   // liczba gier
	SEAT_COUNT                  // gracze potrzebni do gry


// Stany
state
    STATE_IDLE                  // nic nie robienie
    STATE_SEEK                  // aktywna chęć do gry
    STATE_PLAY                  // gra przy stole


// Struktury danych
// Struktura przechowująca informacje o graczu w kolejce
struct queue_position {
    pid : int
    priority : int
    vote: int
}


// Stan "bazowy", rzeczy wykonywane zawsze, niezależnie od stanu
state STATE_BASE {

    priority: int = null                                // priorytet zapytania o stół

    queue: list[pid] = []                               // Kolejka wszystkich graczy chętnych do gry i grających
    table_numbers: array[tid] = [1,2,...,TABLE_NUM]     // Numery stołów

    // Inicjalizacja gry
    table_number: int = null                            // Numer stołu przy którym jesteś
    companions: set[pid] = {}                           // Towarzysze przy stole
    game_ready: int = 0                                 // Liczba gotowych graczy przy stole
    end_ready: int = 0                                  // Liczba gotowych do zakończenia gry
    votes: array[int] = [0,0,0,...]                     // Głosy na poszczególne gry
    chosen_game: int = null                             // Wybrana do zagrania gra

    players_acknowledged: array[bool] = [false,...]     // Gracze o których mamy informacje, że chcą lub nie chcą grać

    // Jakaś gra została zakończona, usuń danych graczy z kolejki
    signal SIG_GAME_END(players: array[int], table_number: int) {
        for (player in players) {
            queue.erase(player)
            players_acknowledged[players] = false

            // Przesuń stół na koniec kolejki
            table_numbers.move_back(table_number)
        }
    }

    signal SIG_TABLE_REQ(priority: int, vote: int) {
        queue.insert(
            queue.find(pririty, signal.pid) // Znajdź miejsce w kolejce na bazie priorytetu, ewentualnie pid 
            { signal.pid, priority, vote }
        )
        players_acknowledged[tabel_req] = true
        send(SIG_TABLE_ACK)
    }

    // Gracz został
    signal SIG_TABLE_ACK() {
        players_acknowledged[SIG_TABLE_ACK] = true
    }

    // Ktoś jest gotowy do zakończenia gry
    signal SIG_END_REQ() {
        end_ready++
    }

}


state STATE_IDLE {

    // Ustaw / resestuj wartości
    table_number = null
    companions = {}
    game_ready = 0
    end_ready = 0
    votes = [0,0,0,...]
    chosen_game = null

    logic {
        wait_for(random())
        priority = lamport_counter
        goto seek;
    }

}


state STATE_SEEK {

    // Odbierz informację o stole
    signal SIG_TABLE(players: array[int], table_number: int) {
        companions = players
        goto(STATE_PLAY)
    }

    logic {
        // Nadaj chęć do gry
        vote = random(0..GAME_NUM)
        broadcast(SIG_TABLE_REQ(priority, vote))

        // Punkt powrotu
        retry:

        // Czekaj na odpowiedzi od innych graczy
        wait_until(all(players_acknowledged))

        // Sprawdź, do którego stołu należysz na bazie kolejki
        players_remaining: int = queue.size
        for (pos = 0; pos < queue.size; pos += SEAT_COUNT) {
            table_index = floor(position / SEAT_COUNT)

            // Nasz gracz należy do stołu
            // Jest ostatnim graczem, więc na prawie timestampów
            //      ma pewność, że nikt przed niego nie wejdzie,
            //      niech on da znać kompanom o stanie stołu
            if (pid in queue[pos+SEAT_COUNT].pid) {
                goto(play {
                    table_number = table_numbers[table_index],
                    companions = { queue[table_index * 4 .. table_index * 4 + SEAT_COUNT].pid }
                })
            }

            players_remaining -= SEAT_COUNT
        }

        // Stoły są pełne, czekaj na wolny stół
        await SIG_GAME_END
        goto :retry
    }

}


state STATE_PLAY {

    logic {

        // Zdobądź głosy, na bazie własnej pozycji i stołu, w którym się znajduje
        own_seat = floor(queue.index / SEAT_COUNT)
        for (pos in queue[own_seat..own_seat+SEAT_COUNT]) {
            votes[queue[pos].vote]++
        }

        // Wybrana gra, sortowana po głosach i ewentualnie id
        chosen_game = votes.sort(value descending, id ascending).first()

        // Granie
        wait_for(random())

        // Gotowość do zakończenia gry
        for comp in companions{
            comp.send(SIG_END_REQ)
        }

        // Wszyscy gotowi do zakończzenia gry
        if (pid == min(companions)) {
            // Tylko jeden gracz wysyła sygnał zakończenia gry
            broadcast(SIG_GAME_END(companions))
        }

        // Powrót do stanu idle
        goto(STATE_IDLE)
    }

}
